### 算法复杂度
在算法复杂度估计时，`语句的总执行次数T(n)` 是关于`问题规模 n` 的`函数`。
进而分析T(n) 随着 n的变化来确定T(n)。
我们用O记法。
一般来说，随着n的增大，T(n)的增速最慢得算法，算是最优算法。

- O(1) 常数阶
- O(n) 线性阶
- O(n^2) 平方阶

####推导时间复杂度大O阶
1. 用常数1取代运行时间中所有的执行次数加法常数
2. 在修改之后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的函数。
4. 得到的即是大O阶。


####常数阶
执行1\2\3次，O(3) ？ 是 O(1)
没有for循环的，平常顺序执行次数。 
####线性阶
如果有for循环，并且循环只有1层，那么就是O(n).
####平方阶
如果有for循环并且循环嵌套2层，那么就是O(n^m). n,m 分别为每层的问题规模。
####对数阶
```java
int count  = 1;
while (count < n) {
  count = count * 2
} //时间复杂度为O(1)的程序步骤
```
由于n每次*2都接近n，也就是说哟多少个n乘以后大于n，就会推出循环。
2^x = n
x = log2n
所以这个循环的时间复杂度为O(logn)

推导时间复杂度
```java
int i ; j;
for (int i = 0; i < n; i++) {
  for (int j = i; j < n; j++ ) {
    /** O(1) 的操作 **/
  }
}
```
n那么这里当j = 0, 内部循环执行 n -0 = n 次， 当j = 1 时，内部循环执行 n -1 知道j = n - 1 时，内部循环执行1次。
即 n + n-1 + n-2 + ... + 1 = n(n+1)/2 = n^2/2 + n/2
由此推导出，O(n^2)

###平均时间复杂度
最好情况下的时间复杂度，最坏情况下的时间复杂度，取平均数。

###常见复杂度：
- 指数阶2^n
- 对数阶logn
- nlogn阶 i.e 3nlogn
- 指数阶 2^n
- O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
